# -*- coding: utf-8 -*-
"""PRIM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q4hrUtkGhoD5aVYXe4dOM7JzUwmVJ_E_
"""

#Prim = O programa é para representação de matriz de adjacência do grafo
#link: https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/
#Biblioteca para o INT_MAX
import sys 

class Graph(): 

   def __init__(self, vertices): 
      self.V = vertices 
      self.graph = [[0 for column in range(vertices)] 
         for row in range(vertices)] 

   #Função para imprimir o MST construído armazenado no parent
   def printMST(self, parent): 
      print("Aresta   Peso")
      for i in range(1, self.V): 
         print(parent[i], "-", i, "\t", self.graph[i][ parent[i] ])

   #encontrar o vértice com valor mínimo de distância, a partir do conjunto de vértices ainda não incluídos na árvore do caminho mais curto
   def minKey(self, key, mstSet): 

   #Inicializa com o valor máximo suportado pelo python (infinito) 
      min = sys.maxsize

      for v in range(self.V): 
         if key[v] < min and mstSet[v] == False: #se a chave for menor e ela ainda não estiver no mstSet, escolha esse vértice.
            min = key[v] 
            min_index = v 
            print(min_index,"min_index", min, "min")

      return min_index 

   #Função para construir e imprimir MST para um gráfico 
   #usando matriz de adjacencia
   def primMST(self): 

   #Valores-chave usados para escolher a aresta de peso mínimo no corte
      key = [sys.maxsize] * self.V #seta todas as chaves como "infinita" e nenhuma delas pertence a mstSet ainda
      parent = [None] * self.V #matriz para armazenar o MST construído
      #Atribua o valor da chave como 0 para o primeiro vértice para que seja escolhido primeiro. 
      key[0] = 0
      mstSet = [False] * self.V #mantem o controle de vértices ainda não incluídos, no começo tudo está como falso

      parent[0] = -1 #O primeiro nó é sempre a raiz, então não possui "pai".

      for cout in range(self.V): 

			#Escolha o vértice de peso mínimo do conjunto de vértices ainda não processados. 
         u = self.minKey(key, mstSet) 

			#Coloque o vértice de peso mínima que retornou da função minKey na árvore.
         mstSet[u] = True

			#Atualize o valor dos vértices adjacentes do vértice escolhido apenas se a distância atual for maior que a nova distância e o vértice não estiver na árvore do caminho 
         for v in range(self.V): 

				   #grafo[u][v] é diferente de zero apenas para vértices adjacentes e v ainda não foi adicionado à árvore
				   #mstSet[v] é falso para vértices ainda não incluídos no MST 
				   #atualize a chave apenas se o grafo[u][v] for menor que key[v](chave atual de v)
            if self.graph[u][v] > 0 and mstSet[v] == False and key[v] > self.graph[u][v]: 
               key[v] = self.graph[u][v] 
               print(key[v],"key[v]")
               parent[v] = u #define o pai de v como u
               print(parent[v],"parent[v]")

      self.printMST(parent) 

g = Graph(5)#0 #1 #2 #3 #4
g.graph = [ [0, 2, 0, 6, 0],#0 
			      [2, 0, 3, 8, 5],#1
			      [0, 3, 0, 0, 7],#2
			      [6, 8, 0, 0, 9],#3
			      [0, 5, 7, 9, 0]]#4

g.primMST(); 

# Contribuído por Divyanshu Mehta